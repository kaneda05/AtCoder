# ABC426
A,Bはただ解くだけ。C問題はいくやってもTLEになってしまう。


## [C問題]()
- PCとOS: 最初、PCがN台あり、それぞれのPCのOSバージョンはPCの番号と同じ（PC1はOS1、PC2はOS2... PCNはOSN）。
- 操作（アップグレード）: Q回の操作が順に行われます。各操作では、X以下のバージョンを持つ全てのPCがYにアップグレード。
- 出力: 各操作で何台のPCがアップグレードされたかを出力。


この問題のポイントは、各PCのOSバージョンが時々刻々変化すること。

単純にPCの状態を1つずつ更新していくと、PCの台数（N）と操作回数（Q）が大きいため、処理時間がかさんでしまう。

##### 方針:`差分配列とポインタの活用`
PCの台数ではなく各OSバージョンにPCが何台存在するかに注目しています。

##### `1.` 差分配列（`d`）の初期化
- dはN+1の要素を持つリスト
d[i]は「**OSバージョンがiのPCが何台あるか**」を表す。
初期状態では、PC1はOS1、PC2はOS2...なので、`d[1], d[2], ..., d[N]`はすべて`1`となります。`d[0]`は使用しないので`0`に設定します。

```python
n, q = map(int, input().split())
d = [1] * (n+1)
d[0] = 0
```

##### `2.` ポインタ(`min`)の役割
`min`は「次にアップグレードの対象となり得る、最も古いOSバージョン」を追跡するためのポインタ。
初期値は`0`。

##### `3.` ループ内での処理

`1.` 対象PCのカウント:`while min <= x:`
- このループは、`min`が`x`以下である限り繰り返す。
`min`は、これまでの操作でまだアップグレードされていない最も古いバージョン。
`x`以下のバージョンを持つPCがアップグレード対象なので、`min`から`x`までのすべてもOSバージョンを持つPCの台数を合計。
- `cnt += d[min]`:`d[min]`に格納されているPCの台数を`cnt`に加算。
- `min += 1`:`min`を１つ進めることで、`min`番目のOSバージョンを持つPCが今回の操作でアップデート対象となるため、次回の操作で見るべき最も古いバージョンは`min+1`になることを意味する。

`2.` 新しいバージョンへの集約:`d[y] += cnt`
- アップデートされた`cnt`台のPCは、すべて新しいバージョン`y`へ
そのため、バージョン`y`を持つPCの台数に、新しくアップデートされた`cnt`台分を追加

```python
for _ in range(q):
    x, y = map(int, input().split())
    cnt = 0
    while min <= x:
        cnt += d[min]
        min += 1
    d[y] += cnt
    print(cnt)
```

### C問題の全体
```python
n, q = map(int, input().split())
d = [1] * (n+1)
d[0] = 0
min = 0

for _ in range(q):
    x, y = map(int, input().split())
    cnt = 0
    while min <= x:
        cnt += d[min]
        min += 1
    d[y] += cnt
    print(cnt)
```

##### コードの実行例
###### 初期状態
- N = 8, Q = 5
- d配列: [0, 1, 1, 1, 1, 1, 1, 1, 1]
- minポインタ: 0

1. 1回目の操作: X = 2, Y = 6
- 目標: バージョン2以下のPCをバージョン6にアップグレード
- 処理: minは1から3まで進む
    - min = 1: cnt += d[1] (1) → cnt = 1
    - min = 2: cnt += d[2] (1) → cnt = 2
- 結果:
    - アップグレードされたPCは2台
    - これらはすべてバージョン6になるため、d[6]に加算される（d[6] = 1 + 2 = 3）
- 状態:
    - d配列: [0, 1, 1, 1, 1, 1, **3**, 1, 1]
    - minポインタ: 3
- 出力: 2

2. 2回目の操作: X = 3, Y = 5
- 目標: バージョン3以下のPCをバージョン5にアップグレード
- 処理: minは現在3です。min <= 3なのでループが実行
    - min = 3: cnt += d[3] (1) → cnt = 1
- 結果:
    - アップグレードされたPCは 1台 
    - これらはバージョン5になるため、d[5]に加算される(d[5] = 1 + 1 = 2)
- 状態:
    - d配列: [0, 1, 1, 1, **2**, **3**, 1, 1]
    - minポインタ: 4
- 出力: 1

3. 3回目の操作: X = 1, Y = 7
- 目標: バージョン1以下のPCをバージョン7にアップグレード
- 処理: minは現在4です。min <= 1という条件は満たされないため、ループは実行されない
- 結果:
    - アップグレードされたPCは0台
    - d配列に変化はなし
- 状態:
    - d配列: [0, 1, 1, 1, **2**, **3**, 1, 1]
    - minポインタ: 4
- 出力: 0

4. 4回目の操作: X = 5, Y = 7
- 目標: バージョン5以下のPCをバージョン7にアップグレード
- 処理: minは現在4です。min <= 5なのでループが実行される
    - min = 4: cnt += d[4] (1) → cnt = 1
    - min = 5: cnt += d[5] (2) → cnt = 1 + 2 = 3
- 結果:
    - アップグレードされたPCは3台
    - これらはバージョン7になるため、d[7]に加算される(d[7] = 1 + 3 = 4)
- 状態:
    - d配列: [0, 1, 1, 1, **2**, **3**, **4**, 1]
    - minポインタ: 6
- 出力: 3

5. 5回目の操作: X = 7, Y = 8
- 目標: バージョン7以下のPCをバージョン8にアップグレード
- 処理: minは現在6です。min <= 7なのでループが実行される
    - min = 6: cnt += d[6] (3) → cnt = 3
    - min = 7: cnt += d[7] (4) → cnt = 3 + 4 = 7
- 結果:
    - アップグレードされたPCは 7台 です。
    - これらはバージョン8になるため、d[8]に加算されます。d[8] = 1 + 7 = 8。
- 状態:
    - d配列: [0, 1, 1, 1, **2**, **3**, **4**, **8**]
    - minポインタ: 8
- 出力: 7